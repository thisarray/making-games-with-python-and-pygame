<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemgem</title>
  <script src="../../jsgame0.js"></script>
  <style type="text/css" media="screen">
body {
  background-color: white;
  color: black;
}
.hidden {
  display: none;
}
#original {
  margin-left: 1em;
}
  </style>
</head>

<body>
<section id="imageLoader" class="hidden">
  <img class="hidden" src="images/gem1.png" alt="gem1" data-name="gem1">
  <img class="hidden" src="images/gem2.png" alt="gem2" data-name="gem2">
  <img class="hidden" src="images/gem3.png" alt="gem3" data-name="gem3">
  <img class="hidden" src="images/gem4.png" alt="gem4" data-name="gem4">
  <img class="hidden" src="images/gem5.png" alt="gem5" data-name="gem5">
  <img class="hidden" src="images/gem6.png" alt="gem6" data-name="gem6">
  <img class="hidden" src="images/gem7.png" alt="gem7" data-name="gem7">
</section>
<section id="soundLoader" class="hidden">
  <audio class="hidden" controls preload="auto" src="sounds/badswap.wav" data-name="badswap">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/match0.wav" data-name="match0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/match1.wav" data-name="match1">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/match2.wav" data-name="match2">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/match3.wav" data-name="match3">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/match4.wav" data-name="match4">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/match5.wav" data-name="match5">Your browser does not support the audio element.</audio>
</section>

<main>
<h1>Gemgem</h1>

<canvas id="screen">
The game screen appears here if your browser supports the Canvas API.
</canvas>
<section id="controls">
  <button type="button" id="reset">Reset</button>
  <button type="button" id="pause">Pause</button>
</section>

<h2>Attribution</h2>

<p>From <a href="https://inventwithpython.com/pygame/chapter10.html">Making Games with Python &amp; Pygame chapter 10</a>.</p>

<p>Original Python code released under a Simplified BSD license.</p>

<p>Images and sounds licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/us/legalcode">Creative Commons BY-NC-SA</a>.</p>

<h2>Original Python code</h2>

<pre id="original"><code>
# Gemgem (a Bejeweled clone)
# By Al Sweigart al@inventwithpython.com
# http://inventwithpython.com/pygame
# Released under a &quot;Simplified BSD&quot; license

&quot;&quot;&quot;
This program has &quot;gem data structures&quot;, which are basically dictionaries
with the following keys:
  &#x27;x&#x27; and &#x27;y&#x27; - The location of the gem on the board. 0,0 is the top left.
                There is also a ROWABOVEBOARD row that &#x27;y&#x27; can be set to,
                to indicate that it is above the board.
  &#x27;direction&#x27; - one of the four constant variables UP, DOWN, LEFT, RIGHT.
                This is the direction the gem is moving.
  &#x27;imageNum&#x27;  - The integer index into GEMIMAGES to denote which image
                this gem uses.
&quot;&quot;&quot;

import random, time, pygame, sys, copy
from pygame.locals import *

FPS = 30 # frames per second to update the screen
WINDOWWIDTH = 600  # width of the program&#x27;s window, in pixels
WINDOWHEIGHT = 600 # height in pixels

BOARDWIDTH = 8 # how many columns in the board
BOARDHEIGHT = 8 # how many rows in the board
GEMIMAGESIZE = 64 # width &amp; height of each space in pixels

# NUMGEMIMAGES is the number of gem types. You will need .png image
# files named gem0.png, gem1.png, etc. up to gem(N-1).png.
NUMGEMIMAGES = 7
assert NUMGEMIMAGES &gt;= 5 # game needs at least 5 types of gems to work

# NUMMATCHSOUNDS is the number of different sounds to choose from when
# a match is made. The .wav files are named match0.wav, match1.wav, etc.
NUMMATCHSOUNDS = 6

MOVERATE = 25 # 1 to 100, larger num means faster animations
DEDUCTSPEED = 0.8 # reduces score by 1 point every DEDUCTSPEED seconds.

#             R    G    B
PURPLE    = (255,   0, 255)
LIGHTBLUE = (170, 190, 255)
BLUE      = (  0,   0, 255)
RED       = (255, 100, 100)
BLACK     = (  0,   0,   0)
BROWN     = ( 85,  65,   0)
HIGHLIGHTCOLOR = PURPLE # color of the selected gem&#x27;s border
BGCOLOR = LIGHTBLUE # background color on the screen
GRIDCOLOR = BLUE # color of the game board
GAMEOVERCOLOR = RED # color of the &quot;Game over&quot; text.
GAMEOVERBGCOLOR = BLACK # background color of the &quot;Game over&quot; text.
SCORECOLOR = BROWN # color of the text for the player&#x27;s score

# The amount of space to the sides of the board to the edge of the window
# is used several times, so calculate it once here and store in variables.
XMARGIN = int((WINDOWWIDTH - GEMIMAGESIZE * BOARDWIDTH) / 2)
YMARGIN = int((WINDOWHEIGHT - GEMIMAGESIZE * BOARDHEIGHT) / 2)

# constants for direction values
UP = &#x27;up&#x27;
DOWN = &#x27;down&#x27;
LEFT = &#x27;left&#x27;
RIGHT = &#x27;right&#x27;

EMPTY_SPACE = -1 # an arbitrary, nonpositive value
ROWABOVEBOARD = &#x27;row above board&#x27; # an arbitrary, noninteger value

def main():
    global FPSCLOCK, DISPLAYSURF, GEMIMAGES, GAMESOUNDS, BASICFONT, BOARDRECTS

    # Initial set up.
    pygame.init()
    FPSCLOCK = pygame.time.Clock()
    DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))
    pygame.display.set_caption(&#x27;Gemgem&#x27;)
    BASICFONT = pygame.font.Font(&#x27;freesansbold.ttf&#x27;, 36)

    # Load the images
    GEMIMAGES = []
    for i in range(1, NUMGEMIMAGES+1):
        gemImage = pygame.image.load(&#x27;gem%s.png&#x27; % i)
        if gemImage.get_size() != (GEMIMAGESIZE, GEMIMAGESIZE):
            gemImage = pygame.transform.smoothscale(gemImage, (GEMIMAGESIZE, GEMIMAGESIZE))
        GEMIMAGES.append(gemImage)

    # Load the sounds.
    GAMESOUNDS = {}
    GAMESOUNDS[&#x27;bad swap&#x27;] = pygame.mixer.Sound(&#x27;badswap.wav&#x27;)
    GAMESOUNDS[&#x27;match&#x27;] = []
    for i in range(NUMMATCHSOUNDS):
        GAMESOUNDS[&#x27;match&#x27;].append(pygame.mixer.Sound(&#x27;match%s.wav&#x27; % i))

    # Create pygame.Rect objects for each board space to
    # do board-coordinate-to-pixel-coordinate conversions.
    BOARDRECTS = []
    for x in range(BOARDWIDTH):
        BOARDRECTS.append([])
        for y in range(BOARDHEIGHT):
            r = pygame.Rect((XMARGIN + (x * GEMIMAGESIZE),
                             YMARGIN + (y * GEMIMAGESIZE),
                             GEMIMAGESIZE,
                             GEMIMAGESIZE))
            BOARDRECTS[x].append(r)

    while True:
        runGame()


def runGame():
    # Plays through a single game. When the game is over, this function returns.

    # initalize the board
    gameBoard = getBlankBoard()
    score = 0
    fillBoardAndAnimate(gameBoard, [], score) # Drop the initial gems.

    # initialize variables for the start of a new game
    firstSelectedGem = None
    lastMouseDownX = None
    lastMouseDownY = None
    gameIsOver = False
    lastScoreDeduction = time.time()
    clickContinueTextSurf = None

    while True: # main game loop
        clickedSpace = None
        for event in pygame.event.get(): # event handling loop
            if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):
                pygame.quit()
                sys.exit()
            elif event.type == KEYUP and event.key == K_BACKSPACE:
                return # start a new game

            elif event.type == MOUSEBUTTONUP:
                if gameIsOver:
                    return # after games ends, click to start a new game

                if event.pos == (lastMouseDownX, lastMouseDownY):
                    # This event is a mouse click, not the end of a mouse drag.
                    clickedSpace = checkForGemClick(event.pos)
                else:
                    # this is the end of a mouse drag
                    firstSelectedGem = checkForGemClick((lastMouseDownX, lastMouseDownY))
                    clickedSpace = checkForGemClick(event.pos)
                    if not firstSelectedGem or not clickedSpace:
                        # if not part of a valid drag, deselect both
                        firstSelectedGem = None
                        clickedSpace = None
            elif event.type == MOUSEBUTTONDOWN:
                # this is the start of a mouse click or mouse drag
                lastMouseDownX, lastMouseDownY = event.pos

        if clickedSpace and not firstSelectedGem:
            # This was the first gem clicked on.
            firstSelectedGem = clickedSpace
        elif clickedSpace and firstSelectedGem:
            # Two gems have been clicked on and selected. Swap the gems.
            firstSwappingGem, secondSwappingGem = getSwappingGems(gameBoard, firstSelectedGem, clickedSpace)
            if firstSwappingGem == None and secondSwappingGem == None:
                # If both are None, then the gems were not adjacent
                firstSelectedGem = None # deselect the first gem
                continue

            # Show the swap animation on the screen.
            boardCopy = getBoardCopyMinusGems(gameBoard, (firstSwappingGem, secondSwappingGem))
            animateMovingGems(boardCopy, [firstSwappingGem, secondSwappingGem], [], score)

            # Swap the gems in the board data structure.
            gameBoard[firstSwappingGem[&#x27;x&#x27;]][firstSwappingGem[&#x27;y&#x27;]] = secondSwappingGem[&#x27;imageNum&#x27;]
            gameBoard[secondSwappingGem[&#x27;x&#x27;]][secondSwappingGem[&#x27;y&#x27;]] = firstSwappingGem[&#x27;imageNum&#x27;]

            # See if this is a matching move.
            matchedGems = findMatchingGems(gameBoard)
            if matchedGems == []:
                # Was not a matching move; swap the gems back
                GAMESOUNDS[&#x27;bad swap&#x27;].play()
                animateMovingGems(boardCopy, [firstSwappingGem, secondSwappingGem], [], score)
                gameBoard[firstSwappingGem[&#x27;x&#x27;]][firstSwappingGem[&#x27;y&#x27;]] = firstSwappingGem[&#x27;imageNum&#x27;]
                gameBoard[secondSwappingGem[&#x27;x&#x27;]][secondSwappingGem[&#x27;y&#x27;]] = secondSwappingGem[&#x27;imageNum&#x27;]
            else:
                # This was a matching move.
                scoreAdd = 0
                while matchedGems != []:
                    # Remove matched gems, then pull down the board.

                    # points is a list of dicts that tells fillBoardAndAnimate()
                    # where on the screen to display text to show how many
                    # points the player got. points is a list because if
                    # the playergets multiple matches, then multiple points text should appear.
                    points = []
                    for gemSet in matchedGems:
                        scoreAdd += (10 + (len(gemSet) - 3) * 10)
                        for gem in gemSet:
                            gameBoard[gem[0]][gem[1]] = EMPTY_SPACE
                        points.append({&#x27;points&#x27;: scoreAdd,
                                       &#x27;x&#x27;: gem[0] * GEMIMAGESIZE + XMARGIN,
                                       &#x27;y&#x27;: gem[1] * GEMIMAGESIZE + YMARGIN})
                    random.choice(GAMESOUNDS[&#x27;match&#x27;]).play()
                    score += scoreAdd

                    # Drop the new gems.
                    fillBoardAndAnimate(gameBoard, points, score)

                    # Check if there are any new matches.
                    matchedGems = findMatchingGems(gameBoard)
            firstSelectedGem = None

            if not canMakeMove(gameBoard):
                gameIsOver = True

        # Draw the board.
        DISPLAYSURF.fill(BGCOLOR)
        drawBoard(gameBoard)
        if firstSelectedGem != None:
            highlightSpace(firstSelectedGem[&#x27;x&#x27;], firstSelectedGem[&#x27;y&#x27;])
        if gameIsOver:
            if clickContinueTextSurf == None:
                # Only render the text once. In future iterations, just
                # use the Surface object already in clickContinueTextSurf
                clickContinueTextSurf = BASICFONT.render(&#x27;Final Score: %s (Click to continue)&#x27; % (score), 1, GAMEOVERCOLOR, GAMEOVERBGCOLOR)
                clickContinueTextRect = clickContinueTextSurf.get_rect()
                clickContinueTextRect.center = int(WINDOWWIDTH / 2), int(WINDOWHEIGHT / 2)
            DISPLAYSURF.blit(clickContinueTextSurf, clickContinueTextRect)
        elif score &gt; 0 and time.time() - lastScoreDeduction &gt; DEDUCTSPEED:
            # score drops over time
            score -= 1
            lastScoreDeduction = time.time()
        drawScore(score)
        pygame.display.update()
        FPSCLOCK.tick(FPS)


def getSwappingGems(board, firstXY, secondXY):
    # If the gems at the (X, Y) coordinates of the two gems are adjacent,
    # then their &#x27;direction&#x27; keys are set to the appropriate direction
    # value to be swapped with each other.
    # Otherwise, (None, None) is returned.
    firstGem = {&#x27;imageNum&#x27;: board[firstXY[&#x27;x&#x27;]][firstXY[&#x27;y&#x27;]],
                &#x27;x&#x27;: firstXY[&#x27;x&#x27;],
                &#x27;y&#x27;: firstXY[&#x27;y&#x27;]}
    secondGem = {&#x27;imageNum&#x27;: board[secondXY[&#x27;x&#x27;]][secondXY[&#x27;y&#x27;]],
                 &#x27;x&#x27;: secondXY[&#x27;x&#x27;],
                 &#x27;y&#x27;: secondXY[&#x27;y&#x27;]}
    highlightedGem = None
    if firstGem[&#x27;x&#x27;] == secondGem[&#x27;x&#x27;] + 1 and firstGem[&#x27;y&#x27;] == secondGem[&#x27;y&#x27;]:
        firstGem[&#x27;direction&#x27;] = LEFT
        secondGem[&#x27;direction&#x27;] = RIGHT
    elif firstGem[&#x27;x&#x27;] == secondGem[&#x27;x&#x27;] - 1 and firstGem[&#x27;y&#x27;] == secondGem[&#x27;y&#x27;]:
        firstGem[&#x27;direction&#x27;] = RIGHT
        secondGem[&#x27;direction&#x27;] = LEFT
    elif firstGem[&#x27;y&#x27;] == secondGem[&#x27;y&#x27;] + 1 and firstGem[&#x27;x&#x27;] == secondGem[&#x27;x&#x27;]:
        firstGem[&#x27;direction&#x27;] = UP
        secondGem[&#x27;direction&#x27;] = DOWN
    elif firstGem[&#x27;y&#x27;] == secondGem[&#x27;y&#x27;] - 1 and firstGem[&#x27;x&#x27;] == secondGem[&#x27;x&#x27;]:
        firstGem[&#x27;direction&#x27;] = DOWN
        secondGem[&#x27;direction&#x27;] = UP
    else:
        # These gems are not adjacent and can&#x27;t be swapped.
        return None, None
    return firstGem, secondGem


def getBlankBoard():
    # Create and return a blank board data structure.
    board = []
    for x in range(BOARDWIDTH):
        board.append([EMPTY_SPACE] * BOARDHEIGHT)
    return board


def canMakeMove(board):
    # Return True if the board is in a state where a matching
    # move can be made on it. Otherwise return False.

    # The patterns in oneOffPatterns represent gems that are configured
    # in a way where it only takes one move to make a triplet.
    oneOffPatterns = (((0,1), (1,0), (2,0)),
                      ((0,1), (1,1), (2,0)),
                      ((0,0), (1,1), (2,0)),
                      ((0,1), (1,0), (2,1)),
                      ((0,0), (1,0), (2,1)),
                      ((0,0), (1,1), (2,1)),
                      ((0,0), (0,2), (0,3)),
                      ((0,0), (0,1), (0,3)))

    # The x and y variables iterate over each space on the board.
    # If we use + to represent the currently iterated space on the
    # board, then this pattern: ((0,1), (1,0), (2,0))refers to identical
    # gems being set up like this:
    #
    #     +A
    #     B
    #     C
    #
    # That is, gem A is offset from the + by (0,1), gem B is offset
    # by (1,0), and gem C is offset by (2,0). In this case, gem A can
    # be swapped to the left to form a vertical three-in-a-row triplet.
    #
    # There are eight possible ways for the gems to be one move
    # away from forming a triple, hence oneOffPattern has 8 patterns.

    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT):
            for pat in oneOffPatterns:
                # check each possible pattern of &quot;match in next move&quot; to
                # see if a possible move can be made.
                if (getGemAt(board, x+pat[0][0], y+pat[0][1]) == \
                    getGemAt(board, x+pat[1][0], y+pat[1][1]) == \
                    getGemAt(board, x+pat[2][0], y+pat[2][1]) != None) or \
                   (getGemAt(board, x+pat[0][1], y+pat[0][0]) == \
                    getGemAt(board, x+pat[1][1], y+pat[1][0]) == \
                    getGemAt(board, x+pat[2][1], y+pat[2][0]) != None):
                    return True # return True the first time you find a pattern
    return False


def drawMovingGem(gem, progress):
    # Draw a gem sliding in the direction that its &#x27;direction&#x27; key
    # indicates. The progress parameter is a number from 0 (just
    # starting) to 100 (slide complete).
    movex = 0
    movey = 0
    progress *= 0.01

    if gem[&#x27;direction&#x27;] == UP:
        movey = -int(progress * GEMIMAGESIZE)
    elif gem[&#x27;direction&#x27;] == DOWN:
        movey = int(progress * GEMIMAGESIZE)
    elif gem[&#x27;direction&#x27;] == RIGHT:
        movex = int(progress * GEMIMAGESIZE)
    elif gem[&#x27;direction&#x27;] == LEFT:
        movex = -int(progress * GEMIMAGESIZE)

    basex = gem[&#x27;x&#x27;]
    basey = gem[&#x27;y&#x27;]
    if basey == ROWABOVEBOARD:
        basey = -1

    pixelx = XMARGIN + (basex * GEMIMAGESIZE)
    pixely = YMARGIN + (basey * GEMIMAGESIZE)
    r = pygame.Rect( (pixelx + movex, pixely + movey, GEMIMAGESIZE, GEMIMAGESIZE) )
    DISPLAYSURF.blit(GEMIMAGES[gem[&#x27;imageNum&#x27;]], r)


def pullDownAllGems(board):
    # pulls down gems on the board to the bottom to fill in any gaps
    for x in range(BOARDWIDTH):
        gemsInColumn = []
        for y in range(BOARDHEIGHT):
            if board[x][y] != EMPTY_SPACE:
                gemsInColumn.append(board[x][y])
        board[x] = ([EMPTY_SPACE] * (BOARDHEIGHT - len(gemsInColumn))) + gemsInColumn


def getGemAt(board, x, y):
    if x &lt; 0 or y &lt; 0 or x &gt;= BOARDWIDTH or y &gt;= BOARDHEIGHT:
        return None
    else:
        return board[x][y]


def getDropSlots(board):
    # Creates a &quot;drop slot&quot; for each column and fills the slot with a
    # number of gems that that column is lacking. This function assumes
    # that the gems have been gravity dropped already.
    boardCopy = copy.deepcopy(board)
    pullDownAllGems(boardCopy)

    dropSlots = []
    for i in range(BOARDWIDTH):
        dropSlots.append([])

    # count the number of empty spaces in each column on the board
    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT-1, -1, -1): # start from bottom, going up
            if boardCopy[x][y] == EMPTY_SPACE:
                possibleGems = list(range(len(GEMIMAGES)))
                for offsetX, offsetY in ((0, -1), (1, 0), (0, 1), (-1, 0)):
                    # Narrow down the possible gems we should put in the
                    # blank space so we don&#x27;t end up putting an two of
                    # the same gems next to each other when they drop.
                    neighborGem = getGemAt(boardCopy, x + offsetX, y + offsetY)
                    if neighborGem != None and neighborGem in possibleGems:
                        possibleGems.remove(neighborGem)

                newGem = random.choice(possibleGems)
                boardCopy[x][y] = newGem
                dropSlots[x].append(newGem)
    return dropSlots


def findMatchingGems(board):
    gemsToRemove = [] # a list of lists of gems in matching triplets that should be removed
    boardCopy = copy.deepcopy(board)

    # loop through each space, checking for 3 adjacent identical gems
    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT):
            # look for horizontal matches
            if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x + 1, y) == getGemAt(boardCopy, x + 2, y) and getGemAt(boardCopy, x, y) != EMPTY_SPACE:
                targetGem = boardCopy[x][y]
                offset = 0
                removeSet = []
                while getGemAt(boardCopy, x + offset, y) == targetGem:
                    # keep checking if there&#x27;s more than 3 gems in a row
                    removeSet.append((x + offset, y))
                    boardCopy[x + offset][y] = EMPTY_SPACE
                    offset += 1
                gemsToRemove.append(removeSet)

            # look for vertical matches
            if getGemAt(boardCopy, x, y) == getGemAt(boardCopy, x, y + 1) == getGemAt(boardCopy, x, y + 2) and getGemAt(boardCopy, x, y) != EMPTY_SPACE:
                targetGem = boardCopy[x][y]
                offset = 0
                removeSet = []
                while getGemAt(boardCopy, x, y + offset) == targetGem:
                    # keep checking, in case there&#x27;s more than 3 gems in a row
                    removeSet.append((x, y + offset))
                    boardCopy[x][y + offset] = EMPTY_SPACE
                    offset += 1
                gemsToRemove.append(removeSet)

    return gemsToRemove


def highlightSpace(x, y):
    pygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, BOARDRECTS[x][y], 4)


def getDroppingGems(board):
    # Find all the gems that have an empty space below them
    boardCopy = copy.deepcopy(board)
    droppingGems = []
    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT - 2, -1, -1):
            if boardCopy[x][y + 1] == EMPTY_SPACE and boardCopy[x][y] != EMPTY_SPACE:
                # This space drops if not empty but the space below it is
                droppingGems.append( {&#x27;imageNum&#x27;: boardCopy[x][y], &#x27;x&#x27;: x, &#x27;y&#x27;: y, &#x27;direction&#x27;: DOWN} )
                boardCopy[x][y] = EMPTY_SPACE
    return droppingGems


def animateMovingGems(board, gems, pointsText, score):
    # pointsText is a dictionary with keys &#x27;x&#x27;, &#x27;y&#x27;, and &#x27;points&#x27;
    progress = 0 # progress at 0 represents beginning, 100 means finished.
    while progress &lt; 100: # animation loop
        DISPLAYSURF.fill(BGCOLOR)
        drawBoard(board)
        for gem in gems: # Draw each gem.
            drawMovingGem(gem, progress)
        drawScore(score)
        for pointText in pointsText:
            pointsSurf = BASICFONT.render(str(pointText[&#x27;points&#x27;]), 1, SCORECOLOR)
            pointsRect = pointsSurf.get_rect()
            pointsRect.center = (pointText[&#x27;x&#x27;], pointText[&#x27;y&#x27;])
            DISPLAYSURF.blit(pointsSurf, pointsRect)

        pygame.display.update()
        FPSCLOCK.tick(FPS)
        progress += MOVERATE # progress the animation a little bit more for the next frame


def moveGems(board, movingGems):
    # movingGems is a list of dicts with keys x, y, direction, imageNum
    for gem in movingGems:
        if gem[&#x27;y&#x27;] != ROWABOVEBOARD:
            board[gem[&#x27;x&#x27;]][gem[&#x27;y&#x27;]] = EMPTY_SPACE
            movex = 0
            movey = 0
            if gem[&#x27;direction&#x27;] == LEFT:
                movex = -1
            elif gem[&#x27;direction&#x27;] == RIGHT:
                movex = 1
            elif gem[&#x27;direction&#x27;] == DOWN:
                movey = 1
            elif gem[&#x27;direction&#x27;] == UP:
                movey = -1
            board[gem[&#x27;x&#x27;] + movex][gem[&#x27;y&#x27;] + movey] = gem[&#x27;imageNum&#x27;]
        else:
            # gem is located above the board (where new gems come from)
            board[gem[&#x27;x&#x27;]][0] = gem[&#x27;imageNum&#x27;] # move to top row


def fillBoardAndAnimate(board, points, score):
    dropSlots = getDropSlots(board)
    while dropSlots != [[]] * BOARDWIDTH:
        # do the dropping animation as long as there are more gems to drop
        movingGems = getDroppingGems(board)
        for x in range(len(dropSlots)):
            if len(dropSlots[x]) != 0:
                # cause the lowest gem in each slot to begin moving in the DOWN direction
                movingGems.append({&#x27;imageNum&#x27;: dropSlots[x][0], &#x27;x&#x27;: x, &#x27;y&#x27;: ROWABOVEBOARD, &#x27;direction&#x27;: DOWN})

        boardCopy = getBoardCopyMinusGems(board, movingGems)
        animateMovingGems(boardCopy, movingGems, points, score)
        moveGems(board, movingGems)

        # Make the next row of gems from the drop slots
        # the lowest by deleting the previous lowest gems.
        for x in range(len(dropSlots)):
            if len(dropSlots[x]) == 0:
                continue
            board[x][0] = dropSlots[x][0]
            del dropSlots[x][0]


def checkForGemClick(pos):
    # See if the mouse click was on the board
    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT):
            if BOARDRECTS[x][y].collidepoint(pos[0], pos[1]):
                return {&#x27;x&#x27;: x, &#x27;y&#x27;: y}
    return None # Click was not on the board.


def drawBoard(board):
    for x in range(BOARDWIDTH):
        for y in range(BOARDHEIGHT):
            pygame.draw.rect(DISPLAYSURF, GRIDCOLOR, BOARDRECTS[x][y], 1)
            gemToDraw = board[x][y]
            if gemToDraw != EMPTY_SPACE:
                DISPLAYSURF.blit(GEMIMAGES[gemToDraw], BOARDRECTS[x][y])


def getBoardCopyMinusGems(board, gems):
    # Creates and returns a copy of the passed board data structure,
    # with the gems in the &quot;gems&quot; list removed from it.
    #
    # Gems is a list of dicts, with keys x, y, direction, imageNum

    boardCopy = copy.deepcopy(board)

    # Remove some of the gems from this board data structure copy.
    for gem in gems:
        if gem[&#x27;y&#x27;] != ROWABOVEBOARD:
            boardCopy[gem[&#x27;x&#x27;]][gem[&#x27;y&#x27;]] = EMPTY_SPACE
    return boardCopy


def drawScore(score):
    scoreImg = BASICFONT.render(str(score), 1, SCORECOLOR)
    scoreRect = scoreImg.get_rect()
    scoreRect.bottomleft = (10, WINDOWHEIGHT - 6)
    DISPLAYSURF.blit(scoreImg, scoreRect)


if __name__ == &#x27;__main__&#x27;:
    main()
</code></pre>
</main>

<script>
/*
 * This program has "gem data structures", which are basically dictionaries
 * with the following keys:
 *  'x' and 'y' - The location of the gem on the board. 0,0 is the top left.
 *                There is also a ROWABOVEBOARD row that 'y' can be set to,
 *                to indicate that it is above the board.
 *  'direction' - one of the four constant variables UP, DOWN, LEFT, RIGHT.
 *                This is the direction the gem is moving.
 *  'imageNum'  - The integer index into GEMIMAGES to denote which image
 *                this gem uses.
 */
WIDTH = 600;  // width of the program's window, in pixels
HEIGHT = 600; // height in pixels
TITLE = 'Gemgem';

const FPS = 30; // frames per second to update the screen

const BOARDWIDTH = 8; // how many columns in the board
const BOARDHEIGHT = 8; // how many rows in the board
const GEMIMAGESIZE = 64; // width & height of each space in pixels

// NUMGEMIMAGES is the number of gem types. You will need .png image
// files named gem0.png, gem1.png, etc. up to gem(N-1).png.
const NUMGEMIMAGES = 7;
console.assert(NUMGEMIMAGES >= 5, 'game needs at least 5 types of gems to work');

// NUMMATCHSOUNDS is the number of different sounds to choose from when
// a match is made. The .wav files are named match0.wav, match1.wav, etc.
const NUMMATCHSOUNDS = 6;

const MOVERATE = 25; // 1 to 100, larger num means faster animations
const DEDUCTSPEED = 0.8; // reduces score by 1 point every DEDUCTSPEED seconds.

//                  R    G    B
const PURPLE    = [255,   0, 255];
const LIGHTBLUE = [170, 190, 255];
const BLUE      = [  0,   0, 255];
const RED       = [255, 100, 100];
const BLACK     = [  0,   0,   0];
const BROWN     = [ 85,  65,   0];
const HIGHLIGHTCOLOR = PURPLE; // color of the selected gem's border
const BGCOLOR = LIGHTBLUE; // background color on the screen
const GRIDCOLOR = BLUE; // color of the game board
const GAMEOVERCOLOR = RED; // color of the "Game over" text.
const GAMEOVERBGCOLOR = BLACK; // background color of the "Game over" text.
const SCORECOLOR = BROWN; // color of the text for the player's score

// The amount of space to the sides of the board to the edge of the window
// is used several times, so calculate it once here and store in variables.
const XMARGIN = Math.trunc((WIDTH - (GEMIMAGESIZE * BOARDWIDTH)) / 2);
const YMARGIN = Math.trunc((HEIGHT - (GEMIMAGESIZE * BOARDHEIGHT)) / 2);

// constants for direction values
const UP = 'up';
const DOWN = 'down';
const LEFT = 'left';
const RIGHT = 'right';

const EMPTY_SPACE = -1; // an arbitrary, nonpositive value
const ROWABOVEBOARD = 'row above board' // an arbitrary, noninteger value

const FONT_SIZE = 36;

// Create pygame.Rect objects for each board space to
// do board-coordinate-to-pixel-coordinate conversions.
const BOARDRECTS = [];
for (let x = 0; x < BOARDWIDTH; x++) {
  BOARDRECTS.push([]);
  for (let y = 0; y < BOARDHEIGHT; y++) {
    BOARDRECTS[x].push(new Rect(XMARGIN + (x * GEMIMAGESIZE),
                                YMARGIN + (y * GEMIMAGESIZE),
                                GEMIMAGESIZE,
                                GEMIMAGESIZE));
  }
}

/*
 * Return a random integer N such that min <= N < max.
 */
function getRandomInteger(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor((Math.random() * (max - min)) + min);
}

const State = Object.freeze({
  PLAY: 1,
  CUTSCENE_BAD: 2,
  CUTSCENE_FILL: 3,
  GAME_OVER: 4
});

var state, gameBoard, score, lastScoreDeduction, firstSelectedGem, secondSelectedGem, finalBoard, cutsceneBoard, cutsceneGems, cutscenePoints;

function reset() {
  state = State.PLAY;

  // initalize the board
  gameBoard = getBlankBoard();
  score = 0;

  // initialize variables for the start of a new game
  firstSelectedGem = null;
  secondSelectedGem = null;
  lastScoreDeduction = 0;

  finalBoard = null;
  cutsceneBoard = null;
  cutsceneGems = null;
  cutscenePoints = null;

  fillBoardAndAnimate(gameBoard, [], score); // Drop the initial gems.
}

function draw() {
  screen.fill(BGCOLOR);
  if (state === State.PLAY) {
    drawBoard(gameBoard);
    if (firstSelectedGem != null) {
      highlightSpace(firstSelectedGem[0], firstSelectedGem[1]);
    }
  }
  else if (state === State.CUTSCENE_BAD) {
    drawBoard(cutsceneBoard);
    for (let gem of cutsceneGems) {
      gem.draw();
    }
  }
  else if (state === State.CUTSCENE_FILL) {
    drawBoard(cutsceneBoard);
    for (let gem of cutsceneGems) {
      gem.draw();
    }
    for (let [value, x, y] of cutscenePoints) {
      screen.draw.text(value.toFixed(0), {
        fontsize: FONT_SIZE,
        color: SCORECOLOR,
        center: [x, y]
      });
    }
  }
  else if (state === State.GAME_OVER) {
    drawBoard(gameBoard);
    screen.draw.text(`Final Score: ${ score } (Click to continue)`, {
      fontsize: FONT_SIZE,
      color: GAMEOVERCOLOR,
      center: [Math.trunc(WIDTH / 2), Math.trunc(HEIGHT / 2)]
    });
  }
  drawScore(score);
}

function update(dt) {
  if (state === State.PLAY) {
    lastScoreDeduction += dt;
    if ((score > 0) && (lastScoreDeduction > DEDUCTSPEED)) {
      // score drops over time
      score -= 1;
      lastScoreDeduction = 0;
    }
  }
  else if (state === State.CUTSCENE_BAD) {
    if (cutsceneGems.every(g => g.animation.done)) {
      // If all the gems have finished moving
      if (finalBoard == null) {
        firstSelectedGem = null;
        secondSelectedGem = null;
        if (!canMakeMove(gameBoard)) {
          state = State.GAME_OVER;
        }
        else {
          state = State.PLAY;
        }
      }
      else {
        // Was not a matching move; swap the gems back
        sounds['badswap'].play();

        finalBoard = null;
        let gem1 = new Actor('gem' + gameBoard[firstSelectedGem[0]][firstSelectedGem[1]]),
            gem2 = new Actor('gem' + gameBoard[secondSelectedGem[0]][secondSelectedGem[1]]);
        gem1.topleft = [XMARGIN + (secondSelectedGem[0] * GEMIMAGESIZE), YMARGIN + (secondSelectedGem[1] * GEMIMAGESIZE)];
        gem2.topleft = [XMARGIN + (firstSelectedGem[0] * GEMIMAGESIZE), YMARGIN + (firstSelectedGem[1] * GEMIMAGESIZE)];

        cutsceneGems = [gem1, gem2];
        cutscenePoints = [];
        gem1.animation = animate(gem1, 0.5, {topleft: gem2.topleft}, 'linear');
        gem2.animation = animate(gem2, 0.5, {topleft: gem1.topleft}, 'linear');
        state = State.CUTSCENE_BAD;
      }
    }
  }
  else if (state === State.CUTSCENE_FILL) {
    if (cutsceneGems.every(g => g.animation.done)) {
      // If all the gems have finished moving
      firstSelectedGem = null;
      secondSelectedGem = null;
      gameBoard = finalBoard;

      let matchedGems = findMatchingGems(gameBoard),
          scoreAdd = 0,
          points = [],
          point;
      if (matchedGems.length > 0) {
        // This was a matching move.

        // Remove matched gems, then pull down the board.

        // points is a list of dicts that tells fillBoardAndAnimate()
        // where on the screen to display text to show how many
        // points the player got. points is a list because if
        // the playergets multiple matches, then multiple points text should appear.
        for (let gemSet of matchedGems) {
          scoreAdd += 10 + ((gemSet.length - 3) * 10);
          for (let [x, y] of gemSet) {
            gameBoard[x][y] = EMPTY_SPACE;
            point = [scoreAdd, (x * GEMIMAGESIZE) + XMARGIN, (y * GEMIMAGESIZE) + YMARGIN];
          }
          points.push(point);
        }
        let name = 'match' + getRandomInteger(0, 6);
        sounds[name].play();
        score += scoreAdd;

        // Drop the new gems.
        fillBoardAndAnimate(gameBoard, points, score);
        // This will implicitly loop around in the game loop to check for more matches
      }
      else {
        if (!canMakeMove(gameBoard)) {
          state = State.GAME_OVER;
        }
        else {
          state = State.PLAY;
        }
      }
    }
  }
}

/*
 * Return true if the gems at the (X, Y) coordinates of the two gems are adjacent.
 */
function isAdjacent(firstXY, secondXY) {
  return (((firstXY[0] === (secondXY[0] + 1)) && (firstXY[1] === secondXY[1])) ||
          ((firstXY[0] === (secondXY[0] - 1)) && (firstXY[1] === secondXY[1])) ||
          ((firstXY[0] === secondXY[0]) && (firstXY[1] === (secondXY[1] + 1))) ||
          ((firstXY[0] === secondXY[0]) && (firstXY[1] === (secondXY[1] - 1))));
}

/*
 * Create and return a blank board data structure.
 */
function getBlankBoard() {
  let board = [];
  for (let x = 0; x < BOARDWIDTH; x++) {
    board.push((new Array(BOARDHEIGHT)).fill(EMPTY_SPACE));
  }
  return board;
}

function copyBoard(board) {
  let result = [];
  for (let x = 0; x < BOARDWIDTH; x++) {
    result.push(board[x].slice());
  }
  return result;
}

/*
 * The patterns in oneOffPatterns represent gems that are configured
 * in a way where it only takes one move to make a triplet.
 */
const ONE_OFF_PATTERNS = [[[0, 1], [1, 0], [2, 0]],
                          [[0, 1], [1, 1], [2, 0]],
                          [[0, 0], [1, 1], [2, 0]],
                          [[0, 1], [1, 0], [2, 1]],
                          [[0, 0], [1, 0], [2, 1]],
                          [[0, 0], [1, 1], [2, 1]],
                          [[0, 0], [0, 2], [0, 3]],
                          [[0, 0], [0, 1], [0, 3]]];

/*
 * Return True if the board is in a state where a matching
 * move can be made on it. Otherwise return False.
 */
function canMakeMove(board) {
  /*
   * The x and y variables iterate over each space on the board.
   * If we use + to represent the currently iterated space on the
   * board, then this pattern: ((0,1), (1,0), (2,0))refers to identical
   * gems being set up like this:
   *
   *     +A
   *     B
   *     C
   *
   * That is, gem A is offset from the + by (0,1), gem B is offset
   * by (1,0), and gem C is offset by (2,0). In this case, gem A can
   * be swapped to the left to form a vertical three-in-a-row triplet.
   *
   * There are eight possible ways for the gems to be one move
   * away from forming a triple, hence oneOffPattern has 8 patterns.
   */
  for (let x = 0; x < BOARDWIDTH; x++) {
    for (let y = 0; y < BOARDHEIGHT; y++) {
      for (let pat of ONE_OFF_PATTERNS) {
        // check each possible pattern of "match in next move" to
        // see if a possible move can be made.
        if ((getGemAt(gameBoard, x + pat[0][0], y + pat[0][1]) === getGemAt(gameBoard, x + pat[1][0], y + pat[1][1])) &&
            (getGemAt(gameBoard, x + pat[1][0], y + pat[1][1]) === getGemAt(gameBoard, x + pat[2][0], y + pat[2][1])) &&
            (getGemAt(gameBoard, x + pat[0][0], y + pat[0][1]) > 0)) {
          return true; // return True the first time you find a pattern
        }
        if ((getGemAt(gameBoard, x + pat[0][1], y + pat[0][0]) === getGemAt(gameBoard, x + pat[1][1], y + pat[1][0])) &&
            (getGemAt(gameBoard, x + pat[1][1], y + pat[1][0]) === getGemAt(gameBoard, x + pat[2][1], y + pat[2][0])) &&
            (getGemAt(gameBoard, x + pat[0][1], y + pat[0][0]) > 0)) {
          return true; // return True the first time you find a pattern
        }
      }
    }
  }
  return false;
}

/*
 * pulls down gems on the board to the bottom to fill in any gaps
 */
function pullDownAllGems(board) {
  for (let x = 0; x < BOARDWIDTH; x++) {
    let column = board[x].filter(g => (g > 0));
    while (column.length < BOARDHEIGHT) {
      column.unshift(EMPTY_SPACE);
    }
    board[x] = column;
  }
}

function getGemAt(board, x, y) {
  if ((x < 0) || (y < 0) || (x >= BOARDWIDTH) || (y >= BOARDHEIGHT)) {
    return -1;
  }
  else {
    return board[x][y];
  }
}

/*
 * Creates a "drop slot" for each column and fills the slot with a
 * number of gems that that column is lacking. This function assumes
 * that the gems have been gravity dropped already.
 */
function getDropSlots(board) {
  let boardCopy = copyBoard(board),
      dropSlots = [],
      ALL_IMAGES = [];
  pullDownAllGems(boardCopy);

  for (let i = 0; i < BOARDWIDTH; i++) {
    dropSlots.push([]);
  }

  for (let i = 1; i <= NUMGEMIMAGES; i++) {
    ALL_IMAGES.push(i);
  }

  // count the number of empty spaces in each column on the board
  for (let x = 0; x < BOARDWIDTH; x++) {
    for (let y = BOARDHEIGHT - 1; y > -1; y--) { // start from bottom, going up
      if (boardCopy[x][y] === EMPTY_SPACE) {
        let possibleGems = new Set(ALL_IMAGES),
            neighborGem, narrowed, newGem;
        for (let [offsetX, offsetY] of [[0, -1], [1, 0], [0, 1], [-1, 0]]) {
          // Narrow down the possible gems we should put in the
          // blank space so we don't end up putting an two of
          // the same gems next to each other when they drop.
          neighborGem = getGemAt(boardCopy, x + offsetX, y + offsetY);
          if ((neighborGem > 0) && possibleGems.has(neighborGem)) {
            possibleGems.delete(neighborGem);
          }
        }
        narrowed = Array.from(possibleGems);
        newGem = narrowed[getRandomInteger(0, narrowed.length)];
        boardCopy[x][y] = newGem;
        dropSlots[x].push(newGem);
      }
    }
  }
  return dropSlots;
}

function findMatchingGems(board) {
  let gemsToRemove = [], // a list of lists of gems in matching triplets that should be removed
      boardCopy = copyBoard(board);

  // loop through each space, checking for 3 adjacent identical gems
  for (let x = 0; x < BOARDWIDTH; x++) {
    for (let y = 0; y < BOARDHEIGHT; y++) {
      if (getGemAt(boardCopy, x, y) <= 0) {
        continue;
      }

      let targetGem = boardCopy[x][y],
          offset = 0,
          removeSet = [];

      // look for horizontal matches
      if ((targetGem === getGemAt(boardCopy, x + 1, y)) &&
          (targetGem === getGemAt(boardCopy, x + 2, y))) {
        offset = 0;
        removeSet = [];
        while (getGemAt(boardCopy, x + offset, y) === targetGem) {
          // keep checking if there's more than 3 gems in a row
          removeSet.push([x + offset, y]);
          boardCopy[x+offset][y] = EMPTY_SPACE;
          offset += 1;
        }
        gemsToRemove.push(removeSet.slice());
      }

      // look for vertical matches
      if ((targetGem === getGemAt(boardCopy, x, y + 1)) &&
          (targetGem === getGemAt(boardCopy, x, y + 2))) {
        offset = 0;
        removeSet = [];
        while (getGemAt(boardCopy, x, y + offset) === targetGem) {
          // keep checking, in case there's more than 3 gems in a row
          removeSet.push([x, y + offset]);
          boardCopy[x][y+offset] = EMPTY_SPACE;
          offset += 1;
        }
        gemsToRemove.push(removeSet.slice());
      }
    }
  }
  return gemsToRemove;
}

function highlightSpace(x, y) {
  screen.draw.rect(BOARDRECTS[x][y], HIGHLIGHTCOLOR, 4);
}

/*
 * Create an Actor for each gem and animate the whole drop instead of row by row.
 */
function fillBoardAndAnimate(board, points, score) {
  finalBoard = copyBoard(board);
  cutsceneBoard = copyBoard(board);
  cutsceneGems = [];
  cutscenePoints = points;

  let dropSlots = getDropSlots(board),
      gem, actor, bottomY;
  for (let x = 0; x < BOARDWIDTH; x++) {
    if (dropSlots[x].length <= 0) {
      continue;
    }

    // Clear the column above the lowest empty space
    for (let y = BOARDHEIGHT - 1; y > -1; y--) {
      if (board[x][y] === EMPTY_SPACE) {
        bottomY = y;
        break;
      }
    }

    for (let y = bottomY - 1; y > -1; y--) {
      cutsceneBoard[x][y] = EMPTY_SPACE;
      gem = board[x][y];
      if (gem === EMPTY_SPACE) {
        continue;
      }

      actor = new Actor('gem' + gem);
      actor.topleft = [XMARGIN + (x * GEMIMAGESIZE), YMARGIN + (y * GEMIMAGESIZE)];
      cutsceneGems.push(actor);
      actor.animation = animate(actor, 0.5 * (bottomY - y), {top: YMARGIN + (bottomY * GEMIMAGESIZE)}, 'linear');
      finalBoard[x][bottomY] = gem;
      bottomY--;
    }

    for (let i = 0; i < dropSlots[x].length; i++) {
      gem = dropSlots[x][i];
      bottomY = dropSlots[x].length - i - 1;
      actor = new Actor('gem' + gem);
      actor.topleft = [XMARGIN + (x * GEMIMAGESIZE), YMARGIN - (GEMIMAGESIZE * (i + 1))];
      cutsceneGems.push(actor);
      actor.animation = animate(actor, 0.5 * (bottomY + i + 1), {top: YMARGIN + (bottomY * GEMIMAGESIZE)}, 'linear');
      finalBoard[x][bottomY] = gem;
    }
  }

  state = State.CUTSCENE_FILL;
}

/*
 * See if the mouse click was on the board
 */
function checkForGemClick(pos) {
  for (let x = 0; x < BOARDWIDTH; x++) {
    for (let y = 0; y < BOARDHEIGHT; y++) {
      if (BOARDRECTS[x][y].collidepoint(pos[0], pos[1])) {
        return [x, y];
      }
    }
  }
  return null; // Click was not on the board.
}

function drawBoard(board) {
  for (let x = 0; x < BOARDWIDTH; x++) {
    for (let y = 0; y < BOARDHEIGHT; y++) {
      screen.draw.rect(BOARDRECTS[x][y], GRIDCOLOR, 1);
      if (board[x][y] !== EMPTY_SPACE) {
        screen.blit('gem' + board[x][y], BOARDRECTS[x][y].topleft);
      }
    }
  }
}

function drawScore(score) {
  screen.draw.text(score.toFixed(0), {
    fontsize: FONT_SIZE,
    color: SCORECOLOR,
    bottomleft: [10, HEIGHT - 6]
  });
}

function on_mouse_down(pos, button) {
  if (state === State.PLAY) {
    // this is the start of a mouse click or mouse drag
    firstSelectedGem = checkForGemClick(pos);
  }
  else if (state === State.GAME_OVER) {
    reset();
  }
}

function on_mouse_up(pos, button) {
  if (state !== State.PLAY) {
    return;
  }

  secondSelectedGem = checkForGemClick(pos);
  if ((firstSelectedGem == null) || (secondSelectedGem == null)) {
    // if not part of a valid drag, deselect both
    firstSelectedGem = null; // deselect the first gem
    return;
  }
  if (!isAdjacent(firstSelectedGem, secondSelectedGem)) {
    firstSelectedGem = null; // deselect the first gem
    return;
  }

  // Two gems have been clicked on and selected. Swap the gems.
  finalBoard = copyBoard(gameBoard);

  // Swap the gems in the board data structure.
  finalBoard[firstSelectedGem[0]][firstSelectedGem[1]] = gameBoard[secondSelectedGem[0]][secondSelectedGem[1]];
  finalBoard[secondSelectedGem[0]][secondSelectedGem[1]] = gameBoard[firstSelectedGem[0]][firstSelectedGem[1]];

  cutsceneBoard = copyBoard(gameBoard);
  cutsceneBoard[firstSelectedGem[0]][firstSelectedGem[1]] = EMPTY_SPACE;
  cutsceneBoard[secondSelectedGem[0]][secondSelectedGem[1]] = EMPTY_SPACE;

  // See if this is a matching move.
  let matchedGems = findMatchingGems(finalBoard);

  // Show the swap animation on the screen.
  let gem1 = new Actor('gem' + gameBoard[firstSelectedGem[0]][firstSelectedGem[1]]),
      gem2 = new Actor('gem' + gameBoard[secondSelectedGem[0]][secondSelectedGem[1]]);
  gem1.topleft = [XMARGIN + (firstSelectedGem[0] * GEMIMAGESIZE), YMARGIN + (firstSelectedGem[1] * GEMIMAGESIZE)];
  gem2.topleft = [XMARGIN + (secondSelectedGem[0] * GEMIMAGESIZE), YMARGIN + (secondSelectedGem[1] * GEMIMAGESIZE)];

  cutsceneGems = [gem1, gem2];
  cutscenePoints = [];
  gem1.animation = animate(gem1, 0.5, {topleft: gem2.topleft}, 'linear');
  gem2.animation = animate(gem2, 0.5, {topleft: gem1.topleft}, 'linear');

  if (matchedGems.length <= 0) {
    state = State.CUTSCENE_BAD;
  }
  else {
    state = State.CUTSCENE_FILL;
  }
}

window.addEventListener('load', (event) => {
  images.LOAD('#imageLoader img');
  sounds.LOAD('#soundLoader audio');
  reset();
  screen.set_mode('#screen', '#reset', '#pause');
});
</script>
</body>

</html>
